<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Earth Spiral Effect</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
    </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.162/examples/jsm/controls/OrbitControls.js';

let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

let renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

let controls = new OrbitControls(camera, renderer.domElement);

/* --------------------- EARTH --------------------- */
/* --------------------- EARTH PARTICLES --------------------- */
const earthTexture = new THREE.TextureLoader().load(
  'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg'
);

const earthMaterial = new THREE.ShaderMaterial({
    uniforms: {
        earthTexture: { value: earthTexture }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = 4.0 * (10.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    `,
    fragmentShader: `
        uniform sampler2D earthTexture;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D(earthTexture, vUv);
            // Hide dark ocean areas to create a "land-only" particle effect
            // if (length(color.rgb) < 0.2) discard; 
            gl_FragColor = vec4(color.rgb, 1.0);
        }
    `,
    transparent: true
});

const earth = new THREE.Points(
    new THREE.SphereGeometry(1, 256, 256),
    earthMaterial
);

// Add a black inner sphere to occlude back-facing particles
const blackSphere = new THREE.Mesh(
    new THREE.SphereGeometry(0.99, 64, 64),
    new THREE.MeshBasicMaterial({ color: 0x000000 })
);
earth.add(blackSphere);

scene.add(earth);

/* --------------------- LIGHT --------------------- */
let light = new THREE.PointLight(0xffffff, 2);
light.position.set(5, 5, 5);
scene.add(light);

/* --------------------- SPIRAL PARTICLES --------------------- */
function generateGalaxy() {
    const parameters = {
        count: 50000,
        size: 0.02,
        radius: 5,
        branches: 3,
        spin: 1,
        randomness: 0.2,
        randomnessPower: 3,
        insideColor: '#ff6030',
        outsideColor: '#1b3984'
    };

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(parameters.count * 3);
    const colors = new Float32Array(parameters.count * 3);
    
    const colorInside = new THREE.Color(parameters.insideColor);
    const colorOutside = new THREE.Color(parameters.outsideColor);

    for(let i = 0; i < parameters.count; i++) {
        const i3 = i * 3;
        const r = Math.random() * parameters.radius;
        const spinAngle = r * parameters.spin;
        const branchAngle = (i % parameters.branches) / parameters.branches * Math.PI * 2;
        
        const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * r;
        const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * r;
        const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * r;

        positions[i3]     = Math.cos(branchAngle + spinAngle) * r + randomX;
        positions[i3 + 1] = randomY;
        positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * r + randomZ;

        const mixedColor = colorInside.clone().lerp(colorOutside, r / parameters.radius);
        colors[i3]     = mixedColor.r;
        colors[i3 + 1] = mixedColor.g;
        colors[i3 + 2] = mixedColor.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: parameters.size,
        sizeAttenuation: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexColors: true
    });

    const points = new THREE.Points(geometry, material);
    return points;
}

const galaxy = generateGalaxy();
scene.add(galaxy);

/* --------------------- ANIMATION --------------------- */
function animate() {
    requestAnimationFrame(animate);

    earth.rotation.y += 0.002;
    galaxy.rotation.y += 0.001;

    renderer.render(scene, camera);
}
animate();

/* --------------------- RESPONSIVE --------------------- */
addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
